
var transToBuffer = function (obj) {
    if (typeof(obj) == 'object') {
        obj = JSON.stringify(obj);
    }
    if (typeof(obj) == 'string') {
        obj = new Buffer(obj);
    }
    if (!Buffer.isBuffer(obj)) {
        throw 'obj transfer to buffer error';
    }
    return obj;
}

var packMsg = function (id, msg) {

    var tempMsg = {
        id: id,
        msg: msg
    };

    var tempMsgBuffer = transToBuffer(tempMsg);

    var result = new Buffer(tempMsgBuffer.length + HeadLength);
    //copy head
    var pos = tempMsgBuffer.length.toByte().copy(result, 0, 0);
    //copy body
    tempMsgBuffer.copy(result, pos, 0);
    return result;
};

var SOCKETS = function () {};
SOCKETS.prototype = [];

SOCKETS.prototype.roomDict = {};

SOCKETS.prototype.broadcast = function (eventId, message, self) {
    console.log("broadcast", eventId, message);
    var packedMsg = packMsg('b_' + eventId, message);
    for (var i = 0; i < this.length; i++) {
        if (this[i] == self) {
            continue;
        }
        this[i].write(packedMsg);
    }
};

SOCKETS.prototype.replaceRoomId = function(socket, targetId) {
    if (socket.__roomId == targetId) {
        return;
    }
    if (socket.__roomId) {
        this.roomDict[socket.__roomId].remove(socket);
        var tempRoomId = socket.__roomId;
        socket.__roomId = null;
        socket.sockets.broadcast('leavec', tempRoomId);
    }
    if (targetId) {
        if (!this.roomDict[targetId]) {
            this.roomDict[targetId] = new SOCKETS();
        }
        this.roomDict[targetId].push(socket);
        socket.__roomId = targetId;
        socket.sockets.broadcast('joinc', targetId);
    }
};

var SOCKET_PROTOTYPE = {
    join: function (targetId) {
        if (!this.__userName) {
            return;
        }
        this.sockets.replaceRoomId(this, targetId);
    },
    leave: function () {
        if (!this.__userName || !this.__roomId) {
            return;
        }
        var tempRoomId = this.__roomId;
        this.sockets.replaceRoomId(this);

        if (this.sockets.roomDict[tempRoomId].length == 0){
            Client.hset(RedisRoomSteps, tempRoomId, JSON.stringify(Rooms[tempRoomId].roomSteps),
                function (err, data) {
                    if(err){
                        return;
                    }
                    Rooms[tempRoomId] = null;
                }
            );
        }
    },
    broadcast: function (eventId, message, notToSelf) {
        if (!this.__userName || !this.__roomId) {
            return;
        }
        this.sockets.roomDict[this.__roomId].broadcast(eventId, message, notToSelf? this:null);
    },
    send: function (eventId, message) {
        if (!eventId){
            eventId = 'default';
        }
        console.log("send:", eventId, message);
        this.write(packMsg(eventId, message));
    }
};

module.exports = {
    sockets: new SOCKETS(),
    init_socket: function (socket) {
        console.log('one user connect   ' + new Date(Date.now()).toTimeString());
        socket = Object.assign(socket, SOCKET_PROTOTYPE);

        var sockets = this.sockets;
        sockets.push(socket);
        socket.sockets = sockets;

        socket.on('close', function () {
            if (!sockets.remove(socket)) {
                console.error("remove socket on close error", sockets, socket);
            }
            socket.leave();
            console.log('one user disconnect    '+ new Date(Date.now()).toTimeString());
        });

        socket.on('error', function (err) {
            console.log(err);
        })
    }
};
